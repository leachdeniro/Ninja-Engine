/*Propiedades sprite de pruebawidth = 196height = 168widthFrame = 28heightFrame = 42 */// Acciones del personaje principalvar CHARACTER_WALK_NORTH = 0,CHARACTER_WALK_EAST = 1,CHARACTER_WALK_SOUTH = 2,CHARACTER_WALK_WEST = 3,CHARACTER_STILL = - 1;// Configuración arreglo de acciones para personaje principalvar arrayPrincipal = [42, 84, 0, 126];/*Clase para la configuración del personaje principal */function Character(src, x, y, z, widthFrame, heightFrame, numRows, numColums, velocity, xsd, ysd, widthCh, heightCh, arraySprite, inS){   // Constructor de la clase padre   Entity.call(this, x, y, widthCh, heightCh, z);   this.walkWest = false;   this.walkEast = false;   this.walkNorth = false;   this.walkSouth = false;   this.action = CHARACTER_WALK_SOUTH;   this.xInit = 300;   this.yInit = 230;   this.image = new Image();   this.image.src = src;   this.widthFrame = widthFrame;   this.heightFrame = heightFrame;   this.numRows = numRows;   this.numColums = numColums;   // posición inicial   this.xPositionOnSprite = 0;   this.yPositionOnSprite = 0;   // variables para controlar velocidad del personaje   this.velocityFactor = velocity;   this.velocity = velocity;   // máximos del Sprite   this.maxWitdhtSprite = widthFrame * numColums - widthFrame;   this.maxHeightSprite = heightFrame * numRows - heightFrame;   // m‡ximos ancho y alto   this.maxWStage = WIDTH - widthCh;   this.maxWStage = this.maxWStage % xsd == 0 ? this.maxWStage : this.maxWStage - (this.maxWStage % xsd);   this.maxHStage = HEIGHT - heightCh;   this.maxHStage = this.maxHStage % ysd == 0 ? this.maxHStage : this.maxHStage - (this.maxHStage % ysd);   // valor desplazamiento de los ejex x y x para el personaje   this.xsd = xsd;   this.ysd = ysd;   // seteo arreglo de sprites   this.arraySprite = arraySprite;   // Coordenadas dentro del escenario   this.xInS = inS.x;   this.yInS = inS.y;   this.maxWidthScenario = W_SCENARIO - widthCh;   this.maxHeightScenario = H_SCENARIO - heightCh;   this.cx = this.x;   this.cy = this.y;   this.draw = function (context)   {      context.drawImage(this.image, this.xPositionOnSprite, this.yPositionOnSprite, this.widthFrame, this.heightFrame, this.x, this.y, this.w, this.h);      this.drawCoordinates(context);   }   this.update = function (dt)   {      // Avanzo las coordenadas del personaje dentro del escenario      this.cx = this.x;      this.cy = this.y;      this.move(dt);      this.advanceInS();      // Chequeo colisiones      /* if (isCollision(this.xInS, this.yInS, this.w, this.h, etapa2))      {      this.x = cx;      this.y = cy;      this.advanceInS();      } */      this.animationSprite(dt);      // Actualizo variable del personaje principal      PERSONAJE_PRINCIPAL.x = this.xInS;      PERSONAJE_PRINCIPAL.y = this.yInS;   }   this.afterCollision = function(type)   {      this.x = this.cx;      this.y = this.cy;      this.advanceInS();   }   /* se desplaza por una imagen   */   this.move = function(dt)   {      if (xor(this.walkEast, this.walkWest) && limitStageX != NONE)      {         this.advance(dt, 2);         if ((this.x >= (this.xInit - this.xsd)) && (this.x <= (this.xInit + this.xsd)))         {            limitStageX = NONE;         }      }      if (xor(this.walkNorth, this.walkSouth) && limitStageY != NONE)      {         this.advance(dt, 1);         if ((this.y >= (this.yInit - this.ysd)) && (this.y <= (this.yInit + this.ysd)))         {            limitStageY = NONE;         }      }   }   this.animationSprite = function(dt)   {      if (this.velocityFactor % this.velocity == 0)      {         if ((this.xPositionOnSprite + this.widthFrame) <= (this.maxWitdhtSprite))         {            this.xPositionOnSprite += this.widthFrame;         }         else         {            this.xPositionOnSprite = 0;         }         this.velocityFactor = 1;      }      else      {         this.velocityFactor += 1;      }      this.yPositionOnSprite = arraySprite[this.action];   }   this.advance = function(dt, type)   {      if (type == 1)      {         if (this.walkNorth)         {            if ((this.y - this.ysd) >= 0)            {               this.y -= this.ysd * dt;            }            else            {               this.y = 0;            }         }         if (this.walkSouth)         {            if ((this.y + this.ysd) <= (this.maxHStage - this.ysd))            {               this.y += this.ysd * dt;            }            else            {               this.y = this.maxHStage;            }         }      }      else if (type == 2)      {         if (this.walkEast)         {            if ((this.x + this.xsd) <= (this.maxWStage - this.xsd))            {               this.x += this.xsd * dt;            }            else            {               this.x = this.maxWStage;            }         }         if (this.walkWest)         {            if ((this.x - this.xsd) >= 0)            {               this.x -= this.xsd * dt;            }            else            {               this.x = 0;            }         }      }   }   this.advanceInS = function()   {      this.xInS = this.x + PLANO.x;      this.yInS = this.y + PLANO.y;   }   this.drawCoordinates = function (context)   {      context.save();      context.fillStyle = 'rgb(255,255,255)';      context.font = 'bold 10px sans-serif';      context.fillText('(x,y)(xis,yis)/lX,lY: (' + this.x + ',' + this.y + ')(' + this.xInS + ',' + this.yInS + ')/' + limitStageX + ',' + limitStageY, 10, 25);      context.restore();   }   this.keyDown = function(event)   {      var updateSprite = false;      if (event.keyCode == 37 && ! this.walkWest)      {         this.walkWest = true;         updateSprite = true;         this.action = CHARACTER_WALK_WEST;      }      if (event.keyCode == 38 && ! this.walkNorth)      {         this.walkNorth = true;         updateSprite = true;         this.action = CHARACTER_WALK_NORTH;      }      if (event.keyCode == 39 && ! this.walkEast)      {         this.walkEast = true;         updateSprite = true;         this.action = CHARACTER_WALK_EAST;      }      if (event.keyCode == 40 && ! this.walkSouth)      {         this.walkSouth = true;         updateSprite = true;         this.action = CHARACTER_WALK_SOUTH;      }      if (updateSprite)      {         this.animationSprite(1);      }   }   this.keyUp = function(event)   {      var updateSprite = false;      if (event.keyCode == 37)      {         this.walkWest = false;         updateSprite = true;      }      if (event.keyCode == 38)      {         this.walkNorth = false;         updateSprite = true;      }      if (event.keyCode == 39)      {         this.walkEast = false;         updateSprite = true;      }      if (event.keyCode == 40)      {         this.walkSouth = false;         updateSprite = true;      }      if (updateSprite)      {         this.animationSprite(1);      }   }}// Extiendo de EntityCharacter.prototype = new Entity();// Acciones del enemigovar ENEMY_WALK_WEST = 0, ENEMY_WALK_EAST = 1;// Configuración arreglo de acciones para el enemigovar arrayEnemy = [0, 48];/*arrayRoad = [xini, xfin]. Rango del eje x por el que se desplaza */function Enemy(src, x, y, z, widthFrame, heightFrame, numRows, numColums, velocity, xsd, ysd, widthCh, heightCh, arraySprite, arrayRoad){   // Constructor de la clase padre   Entity.call(this, x, y, z);   // Dirección al este   this.directionFactor = 1;   this.action = ENEMY_WALK_EAST;   this.arrayRoad = arrayRoad;   this.x = arrayRoad[0];   this.image = new Image();   this.image.src = src;   this.widthFrame = widthFrame;   this.heightFrame = heightFrame;   this.numRows = numRows;   this.numColums = numColums;   // máximos del Sprite   this.maxWitdhtSprite = widthFrame * numColums - widthFrame;   this.maxHeightSprite = heightFrame * numRows - heightFrame;   // posición inicial   this.xPositionOnSprite = 0;   this.yPositionOnSprite = 0;   // variables para controlar velocidad del personaje   this.velocityFactor = velocity;   this.velocity = velocity;   // valor desplazamiento de los ejes "x" e "y" para el personaje   this.xsd = xsd;   this.ysd = ysd;   // Ancho y alto del personaje a pintar. Independiente del tamaño de la imagen   this.widthCh = widthCh;   this.heightCh = heightCh;   // seteo arreglo de sprites   this.arraySprite = arraySprite;   this.draw = function (context)   {      context.drawImage(this.image, this.xPositionOnSprite, this.yPositionOnSprite, this.widthFrame, this.heightFrame, this.x  - X_PLANO, this.y - Y_PLANO, this.widthCh, this.heightCh);   }   this.update = function (dt)   {      // Avanzo las coordenadas del personaje dentro del escenario      var cx = this.x;      var cy = this.y;      this.advance();      // Chequeo colisiones      if (this.collision(PERSONAJE_PRINCIPAL))      {         alert("Ud. ha chocado");      }      this.animationSprite();   }   this.animationSprite = function()   {      if (this.velocityFactor % this.velocity == 0)      {         if ((this.xPositionOnSprite + this.widthFrame) <= (this.maxWitdhtSprite))         {            this.xPositionOnSprite += this.widthFrame;         }         else         {            this.xPositionOnSprite = 0;         }         this.velocityFactor = 1;      }      else      {         this.velocityFactor += 1;      }      this.yPositionOnSprite = arraySprite[this.action];   }   this.advance = function()   {      if (this.x > arrayRoad[1])      {         this.directionFactor = - 1         this.action = ENEMY_WALK_WEST;      }      if (this.x < arrayRoad[0])      {         this.directionFactor = 1;         this.action = ENEMY_WALK_EAST;      }      this.x += this.xsd * this.directionFactor;   }   this.collision = function(entity)   {      if (this.x  + this.widthCh < entity.x)      {         return false;      }      if (this.y + this.heightCh < entity.y)      {         return false;      }      if (this.x  > entity.x + entity.ws)      {         return false;      }      if (this.y  > entity.y + entity.hs)      {         return false;      }      return true;   }}// Extiendo de EntityEnemy.prototype = new Entity();